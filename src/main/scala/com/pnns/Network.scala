package com.pnns

/**
 * Network class. It holds a description of a network and allows to run
 * an algorithm simulation on the network.
 * 
 * @author Ondrej Perutka
 * 
 * @constructor Create a new network instance using given nodes.
 * @param nodes network nodes
 */
class Network(val nodes: Vector[Node]) {

  /**
   * Get number of nodes in the network.
   * 
   * @return network size
   */
  def size = nodes.length

  /**
   * Run simulation of a given algorithm on this network.
   * 
   * @param alg an algorithm
   * @param input input for the algorithm instances
   * @return stopped algorithm instances
   */
  def simulate[I, S, M](alg: Algorithm[I, S, M], input: Vector[I]) = {
    step(createInstances(alg, input))
  }

  /**
   * Simulate one step of an algorithm.
   * 
   * @param instances algorithm instances
   * @return stopped algorithm instances
   */
  private def step[S, M](
    instances: Vector[AlgorithmInstance[S, M]]): Vector[AlgorithmInstance[S, M]] = {
    val messages = sendMessages(instances)
    dispatchMessages(instances, messages)

    if (instances.forall(i => i.hasStopped))
      instances
    else
      step(instances)
  }

  /**
   * Create algorithm instances for all nodes.
   * 
   * @param alg an algorithm
   * @param input input for the algorithm instances
   * @return algorithm instances
   */
  private def createInstances[I, S, M](
    alg: Algorithm[I, S, M],
    input: Vector[I]) = {
    nodes.zip(input) map {
      case (n, i) => alg.createInstance(n, i)
    }
  }

  /**
   * Make all instances send their messages.
   * 
   * @param instances algorithm instances
   * @return messages from all instances
   */
  private def sendMessages[S, M](instances: Vector[AlgorithmInstance[S, M]]) = {
    instances.map(i => i.send)
  }

  /**
   * Dispatch given messages to their destinations.
   * 
   * @param instances algorithm instances
   * @param messages messages generated by the sendMessages() method
   */
  private def dispatchMessages[S, M](
    instances: Vector[AlgorithmInstance[S, M]],
    messages: Vector[Vector[M]]) {
    instances.foreach(i => i.receive(getMessages(i, messages)))
  }

  /**
   * Get messages for a given algorithm instances from all messages generated
   * by the sendMessages() method.
   * 
   * @param instance an algorithm instance
   * @param messages messages generated by the sendMessages() method
   * @return messages for the given algorithm instance
   */
  private def getMessages[S, M](
    instance: AlgorithmInstance[S, M],
    messages: Vector[Vector[M]]) = {
    instance.node.ports map {
      case (v, vport) => messages(v)(vport)
    }
  }
}